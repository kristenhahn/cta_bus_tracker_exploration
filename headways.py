# %%
import requests
from dotenv import load_dotenv
import pandas as pd
import geopandas as gpd
from shapely.geometry import Point, LineString
import datetime as dt
import numpy as np
import pendulum

# import chn-ghost-buses files
import sys
sys.path.append('/Users/kristenhahn/repos/chn-ghost-buses')
from data_analysis.static_gtfs_analysis import *
from scrape_data.scrape_data import *


# %%
# Get API key from the .env file (for actual headway calcs)
load_dotenv()
API_KEY = os.getenv('API_KEY')

# %%

###########
###########
# Scheduled headways from GTFS feed
###########
###########



# %% [markdown]
# # Get Scheduled Stop Times and Headways
#    

# %%
def string_to_datetime(date_string:str) -> pendulum.datetime:
        '''Parameters:\n
        date_string is in the format "YYYY-MM-DD"\n
        Data returned:\n
        specified date as a datetime object.'''
        year = int(date_string[:4])
        month = int(date_string[5:7])
        day = int(date_string[8:])
        return pendulum.datetime(year, month, day)


# %%
def get_scheduled_stop_details(gtfs_feed:GTFSFeed, route_id:str, service_date_string:str) -> pd.DataFrame:
    
    '''Parameters:\n

    gtfs_feed is obtained using the download_extract_format() function from the ghost bus team.\n

    route_id is a route id as a string (for example, '55' for the 55 Garfield bus)\n

    service_date_string is in the format "YYYY-MM-DD", indicating the service date to be analyzed.
    Note that service dates can include spillover into the next calendar day, for bus routes that run
    past midnight.\n

    Data returned:\n

    DataFrame of scheduled stop information for the route and day, including scheduled
    stop times at every bus stop with service IDs and direction of travel.'''

    service_date = string_to_datetime(service_date_string)

    # Get trip summary for service date using chn-ghost-buses make_trip_summary() function
    trip_summary = make_trip_summary(gtfs_feed, service_date, service_date)

    # filter down to the specified route
    trip_summary = trip_summary[trip_summary['route_id'] == route_id]

    # list trip ids for this route
    trip_list = trip_summary['trip_id'].unique().tolist()

    # get stop times data for the trips on this route
    stop_times = gtfs_feed.stop_times

    # filter stop times down to the relevant trips
    stop_times = stop_times.loc[stop_times['trip_id'].isin(trip_list)]

    # Add service id, route, and direction to the stop times data
    stop_times = stop_times.merge(trip_summary[['trip_id', 'route_id', 'service_id', 'direction', 'raw_date']], on='trip_id')

    # Edit the direction column so it matches the format in the chi-hack-night scraped
    # data from the CTA's api
    stop_times['direction'] = stop_times['direction'].apply(lambda x: f'{x}bound')

    # filter stop details down to the relevant route
    stop_times = stop_times.loc[stop_times['route_id'] == route_id]

    # Eliminate duplicates - every line shows up twice.
    # TODO:  Investigate why. Is this related to the calendar_cross line in the 
    # make_trip_summary() function? And/or the fact that I'm using the 
    # same date as start and end date as arguments in make_trip_summary?()
    stop_times = stop_times.drop_duplicates()

    # add stop time as a timestamp
    stop_times['stop_time'] = stop_times['raw_date'] + pd.to_timedelta(stop_times['arrival_time'])

    return stop_times






# %% 
def get_scheduled_stop_ids(scheduled_stop_details):
    return set(scheduled_stop_details['stop_id'])



# %%
def get_active_service_times(stop_details:pd.DataFrame, stop_id:str, direction:str) -> pd.DataFrame:
    
    '''
    Parameters:\n

    stop_details is a dataframe with information on bus stop times
    for a given route and service day.  This is generated by the get_scheduled_stop_details function.\n

    stop_id is a string representing a single bus stop.\n

    direction is a string representing the direction of travel at this stop to be analyzed: 'Northbound',
    'Southbound', 'Eastbound', or 'Westbound'.\n

    Data returned:\n

    Pandas DataFrame containing a row indicating the start and end times for each 
    in-service timeframe. These are continuous time ranges when ANY buses on any service 
    for this route and direction are running at a given bus stop.  identifying these
    allows us to skip out-of-service times in the headway calcs so they don't show up incorrectly
    as long headways.\n

    Note:  Some services only run one bus - these will show the same start and end time.
    '''

    # dataframe to contain service time ranges
    service_ranges = pd.DataFrame()

    # filter stop details to a single stop and direction of travel
    single_stop_details = stop_details.loc[
        stop_details['stop_id'] == stop_id].loc[
            stop_details['direction'] == direction]

    # find service IDs that serve the stop
    service_ids = set(single_stop_details['service_id'])

    # find times when each service starts and ends
    for service_id in service_ids:
        df_service = single_stop_details.loc[single_stop_details['service_id'] == service_id]
        times = df_service['stop_time'].tolist()
        start_time = min(times)
        end_time = max(times)

        # print(f'service id {service_id}, start {start_time}, end {end_time}')

        # make a 2-row dataframe containing start and end times of 
        # one service id at this stop.
        # The adjustment column will be used to cumulatively count the 
        # services running at any given time.  Adding a service means an adjustment
        # of 1, while ending a service means an adjustment of -1.
        df = pd.DataFrame(
            [[service_id, start_time, 1],[service_id, end_time, -1]],
            columns=['service_id', 'time', 'adjustment'])

        # Add this service id's times to the dataframe for all service times
        service_ranges = pd.concat([service_ranges, df])

        # sort by time
        service_ranges.sort_values('time', inplace=True)

        # add a column to show how many services are running (cumulative sum of the 
        # 'adjustment' column)
        service_ranges['services_running'] = service_ranges['adjustment'].cumsum(axis=0)

    # reset the index
    service_ranges.reset_index(inplace=True)


    # generate a list of start and end times when ANY service is active.
    active_service_times = pd.DataFrame()

    # initially there is no start time and no services are running.
    start_time = 0
    previously_inservice = 0

    # iterate through all service id's start and end times. 
    for idx, row in service_ranges.iterrows():

        # prevously no service, service just started: add a start time
        if (previously_inservice == 0) & (row['adjustment'] == 1):
            start_time = row['time']
            # reset previously_inservice variable for the next iteration
            previously_inservice = row['services_running']

        # previously there was at least one service running, last service just ended:  Add an end time
        # and add the start/end times to the dataframe of all continuous active service times.
        elif (previously_inservice > 0) & (row['services_running'] == 0):
            end_time = row['time']
            df_timerange = pd.DataFrame([[start_time, end_time],], columns=['start_time','end_time'])
            active_service_times = pd.concat([active_service_times, df_timerange])
            # reset previously_inservice variable to zero for the next iteration
            previously_inservice = 0

    return active_service_times


# %%

# Get scheduled headways
def get_scheduled_headways(stop_details:pd.DataFrame , stop_id:str, direction:str, active_service_times:pd.DataFrame):

    '''
    Parameters:\n

    stop_details is a dataframe with information on bus stop times
    for a given route and service day.  This is generated by the get_scheduled_stop_details function.\n

    stop_id is a string representing a single bus stop.\n

    direction is a string representing the direction of travel at this stop to be analyzed: 'Northbound',
    'Southbound', 'Eastbound', or 'Westbound'.\n

    Data returned:\n
    '''
    
    # dataframe to contain the output
    df_headways = pd.DataFrame()

    # Moved to arguments for consistency with the get_actual_headways() function
    # # get the start and end of all timeframes when one or more service is actively 
    # # running for the specified stop and direction of travel
    # active_service_times = get_active_service_times(stop_details, stop_id, direction)


    # stop details filtered to one stop_id and direction
    df = stop_details.loc[
        stop_details['stop_id'] == stop_id].loc[
            stop_details['direction'] == direction]

    # sort by arrival time
    df = df.sort_values('arrival_time')

    # add previous stop times to each row
    df['previous_stop_time'] = np.roll(df['stop_time'], shift=1)

    # Calculate headways
    df['headway'] = df['stop_time'] - df['previous_stop_time']

    # Remove the first headway and previous stop time for the first
    # bus in each active service period (no previous arrival time to compare with)
    active_service_starts = active_service_times['start_time'].tolist()

    start_filter = df['stop_time'].isin(active_service_starts)

    df.loc[start_filter, 'headway'] = None
    df.loc[start_filter, 'previous_stop_time'] = None

    return df



# %%

def get_headway_stats(headways:pd.DataFrame, headway_column_name:str, output_column_prefix='') -> pd.DataFrame:
    '''Parameters:\n

    headways is a dataframe obtained using get_headways() or get_scheduled_headways().\n

    headway_column_name is the name of the column containing headways:  'est_headway' if these
    are based on actual bus times using get_actua_headways() or 'scheduled_headway' if these are based
    on GTFS schedules using get_scheduled_headways()\n

    output_column_suffix is an optional string to add to the column names in the 
    final returned dataFrame. This lets you export
    stats for scheduled and actual data into separate column names.

    Data returned:\n
    Statisics on the headways are returned as a dataframe.'''
    
    headways_col = headways[headway_column_name]

    output = pd.DataFrame()
        
    if len(headways) > 0:

        # filter to actual values, not null / nat, nan, etc.
        headways_col = headways_col[pd.notnull(headways_col)].copy()

        col_name_mean = 'mean headway (minutes)'
        col_name_25th = '25th percentile headway (minutes)'
        col_name_median = 'median headway (minutes)'
        col_name_75th = '75th percentile headway (minutes)'

        if output_column_prefix != '':
            col_name_mean = f'{output_column_prefix} {col_name_mean}'
            col_name_25th = f'{output_column_prefix} {col_name_25th}'
            col_name_median = f'{output_column_prefix} {col_name_median}'
            col_name_75th = f'{output_column_prefix} {col_name_75th}'


        # convert to actual minutes as an integer and add to a dataframe

        # if all(headways_col.apply(lambda x: type(x) == pd.Timedelta)):
        output[col_name_mean] = [int(round((headways_col.mean().total_seconds()/60),0))]
        output[col_name_25th] = [int(round((headways_col.quantile(0.25).total_seconds()/60),0))]
        output[col_name_median] = [int(round((headways_col.median().total_seconds()/60),0))]
        output[col_name_75th] = [int(round((headways_col.quantile(0.75).total_seconds()/60),0))]
        
    return output


# %%
###########
###########
# Actual  headways from CTA API
###########
###########



# %%
def get_chn_vehicles(date_string:str) -> pd.DataFrame:
    """Parameters:\n

    date_string in 'YYYY-MM-DD'format\n

    Data returned:\n

    Vehicle data scraped by the chn ghost bus team for all CTA buses running on the specified
    calendar date and the following date.
    
    Data is returned in a pandas dataframe. Columns include vehicle id (vid), timestamp (tmstmp), 
    pattern id (pid), and distance along the pattern (pdist) for each vehicle at 5-minute intervals 
    throughout the requested time range on the requested calendar day.
    """

    day1 = pd.to_datetime(date_string, infer_datetime_format=True)
    day2 = day1 + pd.Timedelta(days=1)
    day2_string = day2.strftime('%Y-%m-%d')

    # start_timedelta_string_expanded = start_timedelta_string + ':00'
    # end_timedelta_string_expanded = end_timedelta_string + ':00'

    def get_vehicles_single_day(single_day_datestring):
        chn_data_source_single_day = f'https://chn-ghost-buses-public.s3.us-east-2.amazonaws.com/bus_full_day_data_v2/{single_day_datestring}.csv'
        vehicles_single_day = pd.read_csv(
        chn_data_source_single_day, dtype={
            'vid':'int',
            'tmstmp':'str',
            'lat':'float',
            'lon':'float',
            'hdg':'int',
            'pid':'int',
            'rt':'str',
            'pdist':'int',
            'des':'str',
            'dly':'bool',
            'tatripid':'str',
            'origatripno':'int',
            'tablockid':'str',
            'zone':'str',
            'scrape_file':'str',
            'data_hour':'int',
            'data_date':'str'
            }
        )

        vehicles_single_day['tmstmp'] = pd.to_datetime(vehicles_single_day['tmstmp'],infer_datetime_format=True,utc=True)
    
        return vehicles_single_day

    df_day1_vehicles = get_vehicles_single_day(date_string)
    df_day2_vehicles = get_vehicles_single_day(day2_string)
    
    df_both_days_vehicles = pd.concat([df_day1_vehicles, df_day2_vehicles])
 
    return df_both_days_vehicles



# %%
def get_patterns(vehicles:pd.DataFrame, rt:str) -> pd.DataFrame:
    '''This is a helper function.\n
    Parameters:\n
    vehicles is a dataframe obtained using get_chn_vehicles().\n
    rt is a route id as a string (for example, '55' for the 55 Garfield bus)\n
    Data returned:\n
    patterns data from the CTA's bus tracker API is returned in a dataframe. 
    It includes all pattern ids (pid) found in the in the vehicles data for the specified
    route. Columns include pattern id (pid) and points (pt).\n
    The pt data for each pattern is its own dataframe with information on every point
    along the pattern. It includes columns for sequence (seq), latitude (lat),
    longitude (lon), type of points (typ) where S indicates a bus stop,
    stop ID (stpid) for stop points, and distance along the pattern (pdist).
     '''
    
    df_output = pd.DataFrame()

    # filter vehicles to the specified route
    rt_vehicles = vehicles.loc[vehicles['rt'] == rt]

    # list pid values included in the route
    pid_list = list(rt_vehicles['pid'].unique())

    # convert pids to strings
    pid_list = [str(i) for i in pid_list]

    # split pid_list into chunks of 10 (limit of the API):
    start = 0
    end = len(pid_list)
    step = 10
    for i in range(start, end, step):
        pid_list_chunk = pid_list[i:i+step]
        pid_string = ','.join(pid_list_chunk)

        # get data from CTA's feed
        api_url = f'http://www.ctabustracker.com/bustime/api/v2/getpatterns?key={API_KEY}&pid={pid_string}&format=json'
        response = requests.get(api_url)
        patterns = response.json()

        # convert json to dataframe
        df_patterns = pd.DataFrame(patterns['bustime-response']['ptr'])

        # add to the output dataframe
        df_output = pd.concat([df_output, df_patterns])


    # convert pt column values to dataframes for each pattern containing that pattern's points
    df_output['pt'] = df_output['pt'].apply(lambda x: pd.DataFrame(x))
    
    return df_output



# %%
def get_pattern_linestrings(patterns:pd.DataFrame) -> gpd.GeoDataFrame:
    '''This is for future use and visualization - not neccessary to generate
    headway information.\n
    Paremeters:\n
    patterns is a dataframe obtained using get_patterns().\n
    Data returned:\n
    Pattern data is returned as a geodataframe wiht linestring geometry
    representing the path buses travel.'''

    df_patterns = patterns.copy()

    # Turn points into linestrings
    geometry_linestrings = []
    for p in df_patterns['pt']:
        p.sort_values('seq', inplace=True)
        linestring_points = list(zip(p['lon'],p['lat']))

        # generate linestring using all points
        linestring = LineString(linestring_points)
        geometry_linestrings.append(linestring)

    # Create a geodataframe for the patterns using the linestring geometry
    gdf_patterns = gpd.GeoDataFrame(df_patterns, geometry=geometry_linestrings).set_crs(epsg=4326)

    # Drop the original pt column
    gdf_patterns.drop(['pt'], axis=1, inplace=True)

    return gdf_patterns


# %%
def get_pattern_stops(patterns) -> gpd.GeoDataFrame:
        '''This is a helper function.\n
        Parameters:\n
        patterns is a dataframe obtained using get_patterns().\n
        Data returned:\n
        Bus stop data is returned as a geodataframe 
        with point geomtry, one point per bus stop on each pattern
        associated with a route.\n
        Note that stops serving multiple patterns will be listed multiple 
        times, once for each pattern with the seq and pdist values 
        specific to that pattern.'''

        # get patterns for the route
        df_patterns = patterns.copy()

        # set up a geodataframe to contain stops
        gdf_route_stops = gpd.GeoDataFrame()

        # consider the pid column (pattern ID) and the pt column (dataframe contaning
        # points along the pattern)
        for pid, pt in zip(df_patterns['pid'],df_patterns['pt']):
                # sort points sequentially
                pt.sort_values('seq', inplace=True)
                # add the pattern id to each point's data
                pt['pid']=pid
                # add the pattern direction to each point's data
                rtdir = df_patterns['rtdir'].loc[df_patterns['pid'] == pid].tolist()[0]
                pt['rtdir'] = rtdir
                # filter to only show stop points
                stops = pt[pt['typ']=='S']
                # zip lat/lon data to get coordinate pairs
                coords = list(zip(stops['lon'],stops['lat']))
                # turn coordinates into point geometry
                geometry = [Point(c) for c in coords]
                # generate a geodataframe for the stops in this pattern
                gdf_pattern_stops = gpd.GeoDataFrame(stops,geometry=geometry).set_crs(epsg=4326)
                # add this pattern's stops to the dataframe containing all stops on the route
                gdf_route_stops = pd.concat([gdf_route_stops, gdf_pattern_stops])
                # # change stpid and rtrid columns to strings
                # gdf_route_stops['stpid'] = gdf_route_stops['stpid'].astype('string')
                # gdf_route_stops['rtdir'] = gdf_route_stops['rtdir'].astype('string')

        return gdf_route_stops




# %%
def get_vehicle_intervals(vehicles:pd.DataFrame, rt:str) -> pd.DataFrame:

    '''This is a helper function.\n
    Parameters:\n
    vehicles is a dataframe obtained using get_chn_vehicles().\n
    Data returned:\n
    Intervals are returned as a dataframe, with each row representing
    an interval between two points in time and space for one vehicle. 
    Columns are added to the vehicles data for each interval's 
    start time, end time, start pdist, and end pdist.'''

    df_vehicles = vehicles.copy()

    # filter to the specified route
    df_vehicles = df_vehicles.loc[df_vehicles['rt'] == rt]

    # Set up dataframe to contain final fomratted data
    df_output = pd.DataFrame()

    # End time for each interval as a timestamp
    # df_vehicles['end_time'] = pd.to_datetime(df_vehicles['tmstmp'],infer_datetime_format=True)
    df_vehicles['end_time'] = df_vehicles['tmstmp']
    vid_list = df_vehicles['vid'].unique().tolist()

    # End location for each interval
    df_vehicles['end_pdist'] = df_vehicles['pdist']

    for vid in vid_list:

        # pare data down to a single vehicle
        df_vehicle = df_vehicles.loc[df_vehicles['vid'] == vid]

        # handle each pattern separately
        pid_list = df_vehicle['pid'].unique().tolist()
        for p in pid_list:
            df_vehicle_pattern = df_vehicle.loc[df_vehicle['pid']==p].copy()
            # sort by time (it should be sorted already, but just in case)
            df_vehicle_pattern.sort_values(by=['end_time'], inplace=True)

            # Create a start time based on the previous timestamp
            end_times = df_vehicle_pattern['end_time'].tolist()
            start_times = np.roll(end_times,shift=1)
            df_vehicle_pattern['start_time'] = start_times

            # Create a start pattern distance based on the previous pdist
            end_distances = df_vehicle_pattern['end_pdist'].tolist()
            start_distances = np.roll(end_distances,shift=1)
            df_vehicle_pattern['start_pdist'] = start_distances

            # Remove the first interval since we don't have real start
            # time or location data for it
            df_vehicle_pattern = df_vehicle_pattern.iloc[1:]

            # add data to the full output dataframe
            df_output = pd.concat([df_output, df_vehicle_pattern])

    return df_output



# %%
def interpolate_stop_time(
    stop_pdist:int, 
    start_time:pd.Timestamp, 
    end_time:pd.Timestamp, 
    start_pdist:int, 
    end_pdist:int
    ) -> pd.Timestamp:

    '''This is a helper function.\n
    Parameters:\n
    stop_pdist is an integer distance along a pattern to a given bus stop.\n
    start_time and end_time are timestamps for the beginning and end of an interval.\n
    start_pdist and end_pdist are integer distances along a pattern at the beginning and
    end of an interval.\n
    Data returned:\n
    timestamp for the estimated time a vehicle reached a stop, assuming it
    traveled a constant speed from start to end of teh interval
    '''

    # How far into the interval distance is the bus stop?
    # stop distance from beginning of interval / full interval distance
    dist_ratio = (stop_pdist-start_pdist)/(end_pdist-start_pdist)

    # estimated bus stop time, assuming it traveled at a steady
    # speed throughout the interval
    est_stop_time = start_time + (end_time - start_time)*dist_ratio

    # round estimated stop time to the nearest second
    est_stop_time = est_stop_time.round('1s')

    return est_stop_time


# %%
def get_actual_stoptimes(rt:str, vehicles:pd.DataFrame) -> pd.DataFrame:

    '''This is a helper function.\n
    Parameters:\n
    vehicles is a dataframe obtained using get_chn_vehicles().\n
    rt is a route id as a string (for example, '55' for the 55 Garfield bus)\n
    Data returned:\n
    Columns are added to the vehicles dataframe indicating the start and end time
    and the start and end distances along a pattern for each interval where a bus
    passed a stop (start_time, end_time, start_pdist, end_pdist). The estimated time 
    each bus actually arrived at the stop (est_stop_time) is also added.\n
    The dataframe returned covers all buses at all stops on the specified route'''
 
    # set up a dataframe to contain the output data
    df_output = pd.DataFrame()

    # turn vehicle data into intervals between vehicles
    vehicle_intervals = get_vehicle_intervals(vehicles, rt)

    # get pattern data from the CTA
    df_patterns = get_patterns(vehicles, rt)

    # get all stops on this route, including all patterns
    gdf_stops = get_pattern_stops(df_patterns)

    # Consider each combination of stop and pattern
    for stpid, pid, rtdir in list(zip(gdf_stops['stpid'],gdf_stops['pid'], gdf_stops['rtdir'])):

        # get a single stop on a single pattern
        gdf_this_stop_pattern = gdf_stops.loc[(gdf_stops['stpid'] == stpid) & (gdf_stops['pid'] == pid)].copy()
        if len(gdf_this_stop_pattern) == 0:
            continue
            
        # Find the bus stop's distance along the pattern
        pdist_this_stop = gdf_this_stop_pattern['pdist'].tolist()[0]

        # find the intervals that are on this pattern
        df_this_pattern_intervals = vehicle_intervals.loc[vehicle_intervals['pid'] == pid].copy()
        if len(df_this_pattern_intervals) == 0:
            continue

        # Filter for intervals that start ahead of the stop location and end at or beyond the stop
        def filter_intervals(stop_dist:int, start_pdist:int, end_pdist:int):
            return (start_pdist < stop_dist) & (end_pdist >= stop_dist)
    
        # Create filter for the intervals we're working on
        interval_filter = df_this_pattern_intervals.apply(
            lambda x: filter_intervals(pdist_this_stop, x['start_pdist'], x['end_pdist']), axis=1
            )
        
        # apply the filter
        df_this_pattern_stop_intervals = df_this_pattern_intervals.loc[interval_filter].copy()
        if len(df_this_pattern_stop_intervals) == 0:
            continue

        # Add stpid, pdist, and rtdir to the data
        df_this_pattern_stop_intervals['stpid'] = stpid
        df_this_pattern_stop_intervals['stop_pdist'] = int(pdist_this_stop)
        df_this_pattern_stop_intervals['rtdir'] = rtdir


        # Estimate time each bus passed the stop (interpolated based on data at start and
        # end of the interval)
        df_this_pattern_stop_intervals['est_stop_time'] = df_this_pattern_stop_intervals.apply(
            lambda x: interpolate_stop_time(
                pdist_this_stop, 
                x['start_time'], 
                x['end_time'], 
                x['start_pdist'], 
                x['end_pdist']), axis=1
            )

        # Add the intervals with stop times to the full output dataframe
        df_output = pd.concat([df_output, df_this_pattern_stop_intervals])

        # # change to strings - why to they keep popping up as objects
        # # by the end of each function?
        # df_output['rt'] = df_output['rt'].astype('string')
        # df_output['stpid'] = df_output['stpid'].astype('string')
        # df_output['rtdir'] = df_output['rtdir'].astype('string')

    return df_output

# %%
def get_actual_stop_ids(actual_stoptimes):
    return set(actual_stoptimes['stpid'])



# %%
# %%

def get_actual_headways(
    vehicles:pd.DataFrame, rt:str, stop_id:str, direction:str, 
    active_service_times:list) -> pd.DataFrame:

        '''
        Parameters:\n

        vehicles is a dataframe obtained using get_chn_vehicles().\n

        rt is a route id as a string (for example, '55' for the 55 Garfield bus)\n

        stop_id is the stop id of a single bus stop as a string.\n

        direction is the direction of travel as a string: 'Northbound', 'Southbound', 
        'Eastbound', or 'Westbound'

        active_service_times is a list of start/end times when buses are 
        scheduled to be in service at a given stop. This list is generated
        by the get_active_service_times() function.\n

        Data returned:\n
        Columns are added to the vehicles dataframe indicating :\n
        - the start and end time and the start and end distances along a pattern for each interval where a bus
        passed a stop (start_time, end_time, start_pdist, end_pdist),\n
        - the estimated time each bus actually arrived at the stop (est_stop_time), and headway between each 
        bus (est_headway).  
        - Direction of travel (rtdir) and stop id (stpid) are also included.\n
        Headways are not calculated for the first bus in each active service period.  This
        ensures that regularly scheduled out-of-service periods do not appear as long headways.
        '''

        df_output = pd.DataFrame()

        # Times buses stopped at each stop on the route
        df_stoptimes = get_actual_stoptimes(rt, vehicles).copy()

        # Filter to buses stopping at the specified stop in the specified direction
        df_stop_direction = df_stoptimes.loc[
            (df_stoptimes['stpid'] == stop_id)]

        df_stop_direction = df_stop_direction.loc[
            (df_stop_direction['rtdir'] == direction)]

        # Consider each active service timeframe
        for start_time, end_time in list(zip(
            active_service_times['start_time'],
            active_service_times['end_time'])):

            # print(f'{start_time} to {end_time}')

            # filter for stops happening after the service time start
            df_stop_direction_servicetime = df_stop_direction.loc[
                df_stop_direction['est_stop_time'] >= start_time
                ]

            # filter for stops happening before the service time end
            df_stop_direction_servicetime = df_stop_direction_servicetime.loc[
                df_stop_direction_servicetime['est_stop_time'] <= end_time
                ]

            # print(df_stop_direction_servicetime)

            # proceed if there are any stops within the service time window:
            if len(df_stop_direction_servicetime) > 0:

                # Sort chronologically
                df_stop_direction_servicetime.sort_values(by='est_stop_time',ascending=True, inplace=True)

                # list stop times in chronological order
                stop_times = df_stop_direction_servicetime['est_stop_time'].tolist()

                # calculate previous stop time for each line
                prev_stop_times = np.roll(stop_times,1)
                df_stop_direction_servicetime['previous_stop_time'] = prev_stop_times

                # calculate headway
                df_stop_direction_servicetime['est_headway'] = (
                    df_stop_direction_servicetime['est_stop_time'] 
                    - df_stop_direction_servicetime['previous_stop_time']
                    )

                # drop previous stop time column, no longer needed
                df_stop_direction_servicetime = df_stop_direction_servicetime.drop(
                        'previous_stop_time', axis=1)

                # Remove headwat for the first bus in the dataset since we don't have the 
                # previous bus to compare with
                df_stop_direction_servicetime['est_headway'].iloc[0] = None
                    
                df_output = pd.concat([df_output, df_stop_direction_servicetime])

        return df_output


# %%
def get_average_wait_time(headways:pd.DataFrame) -> pd.DataFrame:
    '''Parameters:\n
    headways is a dataframe obtained using get_actual_headways().\n
    Data returned:\n
    Average wait time (AWT) value by stop ID.'''

    # AWT = SUM(D^2)/2T, where D = the duration between arrivals and T = the timeframe duration.
    # When D=T, this simplifies to AWT = D/T
    stops = pd.DataFrame()
    stops['stpid'] = headways['stpid'].unique()
    
    AWTs = []
    mean = []
    for stop in stops['stpid']:
        stop_visits = headways[headways['stpid'] == stop]
        
        start = stop_visits['start_time'].min()
        end = stop_visits['end_time'].max()
        timeframe_duration = pd.Timedelta(end-start).seconds/60.0

        headway_minutes = stop_visits['est_headway'].dt.total_seconds()/60
        AWT = ((headway_minutes)**2).sum()/(2*timeframe_duration)
        AWTs.append(AWT)

        mean.append(headway_minutes.mean())

    stops['AWT'] = AWTs
    stops['mean_headway'] = mean
    return stops

# %%

## Get summary headway stats for every stop on a single route for a single service day

def get_stats_all_stops(gtfs_feed, route_id, service_date_string):
    '''
    Returns a geodataframe of every bus stop on a specified route, with stats on 
    actual and scheduled headways for a single service day.  This data is also exported as a
    geojson.\n

    Parameters:\n

    gtfs_feed is obtained using the download_extract_format() function from the ghost bus team.\n

    route_id is a route id as a string (for example, '55' for the 55 Garfield bus)\n

    service_date_string is in the format "YYYY-MM-DD", indicating the service date to be analyzed.
    Note that service dates can include spillover into the next calendar day, for bus routes that run
    past midnight.\n

    Data returned:\n

    Returns a geodataframe containing all stops with actual and scheduled headway statistics.\n
    
    Exports the headway summary data for each stop as a geojson to the headway_summaries directory.\n
    Also exports a linestring for the selected route as a geojson.
    '''

    # dataframe to contain final summary data for each stop
    stats_all_stops = gpd.GeoDataFrame()

    # get scheduled stop details
    scheduled_stop_details = get_scheduled_stop_details(gtfs_feed, route_id, service_date_string)
    # get scheduled stop ids
    scheduled_stop_ids = get_scheduled_stop_ids(scheduled_stop_details)


    # get vehicles
    vehicles = get_chn_vehicles(service_date_string)
    # get actual stop times
    actual_stoptimes = get_actual_stoptimes(route_id, vehicles)
    # get actual stop ids
    actual_stop_ids = get_actual_stop_ids(actual_stoptimes)
                                          
    # get stops found in both the live data and the gtfs schedule data
    common_stops = actual_stop_ids.intersection(scheduled_stop_ids)

    for stop_id in common_stops:

        # list directions found in the data for this stop
        directions = actual_stoptimes.loc[actual_stoptimes['stpid'] == stop_id]['rtdir'].unique().tolist()

        for direction in directions:

            # get active service times
            active_service_times = get_active_service_times(scheduled_stop_details,stop_id, direction)

            # get scheduled headway stats
            scheduled_headways = get_scheduled_headways(scheduled_stop_details, stop_id, direction, active_service_times)
            # Remove rows without headways (first bus in each active service time)
            scheduled_headways = scheduled_headways[scheduled_headways['headway'].notnull()]
            scheduled_headway_stats = get_headway_stats(scheduled_headways, 'headway', 'Scheduled')


            # get actual headway stats within active service times
            actual_headways = get_actual_headways(vehicles, route_id, stop_id, direction, active_service_times)
            # Remove rows without headways (first bus in each active service time)
            actual_headways = actual_headways[actual_headways['est_headway'].notnull()]
            actual_headway_stats = get_headway_stats(actual_headways, 'est_headway', 'Actual')

            # get basic stop info
            stop_df = pd.DataFrame()
            stop_df['stop_id'] = [stop_id]
            stop_df['route_id'] = [route_id]
            # date
            stop_df['date'] = [service_date_string]
            # day of week
            stop_df['day'] = pd.to_datetime(stop_df['date'],infer_datetime_format=True).dt.day_name()
            stop_df['direction'] = [direction]

            # add headway data to stop info
            stats_for_one_stop_df = pd.concat([stop_df, actual_headway_stats, scheduled_headway_stats], axis=1)
            # stats_for_one_stop_df.reset_index(inplace=True, drop=True)

            # add stop info to the dataframe containing info on all stops
            stats_all_stops = pd.concat([stats_all_stops, stats_for_one_stop_df], axis = 0)
            # stats_all_stops.reset_index(inplace=True, drop=True)
            # print(stats_all_stops.columns)

    # combine bus stop geospatial info with the stats dataframe
    # to generate a geojson with stats for every stop point
    patterns = get_patterns(vehicles, route_id)
    stops = get_pattern_stops(patterns)
    route_linestring = get_pattern_linestrings(patterns)

    # merge stop geodataframe with headway stats
    df_stops = gpd.GeoDataFrame(stops[['stpid', 'stpnm', 'geometry']])
    stats_all_stops = stats_all_stops.merge(df_stops, left_on='stop_id', right_on='stpid')

    stats_all_stops = stats_all_stops.drop('stpid', axis=1)
    stats_all_stops = stats_all_stops.rename(columns={'stpnm':'stop name', 'stop_id':'stop id'})
    stats_all_stops.reset_index(inplace = True, drop = True)

    # Export stop data to geojson
    json_filepath_stops = f'headway_summaries/route{route_id}_{service_date_string}.json'
    stats_all_stops.to_file(filename=json_filepath_stops, driver='GeoJSON')

    # export route linestring data to geojson
    json_filepath_linestring = f'headway_summaries/route{route_id}_linestring.json'
    route_linestring.to_file(json_filepath_linestring, driver='GeoJSON')

    return stats_all_stops


# %%
